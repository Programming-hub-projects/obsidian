S - Принцип единственной ответственности - класс выполняет одно действие.
O - Принцип открытости/закрытости (open-closed principle) - мржно дополнять, но не менять.
L - Принцип подстановки Лисков (Liskov substitution principle) - «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом». Подклассы должны дополнять, а не замещать поведе-
ние базового класса.
I - Принцип разделения интерфейса (interface segregation principle). Интерфейсы должны быть маленькими и специфическими для каждого клиента, а не общими для всех. Клиенты не должны зависеть от методов, которые они
не используют.
D - Принцип инверсии зависимостей (dependency inversion principle) - зависимости внутри системы должны быть направлены от абстракций к конкретным реализациям, а не наоборот. Это позволяет более гибко управлять зависимостями и улучшить тестируемость и переиспользуемость кода.


**S**
##### Принцип единственной ответственности (single responsibility principle)
* Для класса должен быть только один мотив для изменения.
* Для каждого класса должно быть определено единственное назначение. 
* Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Пример
Класс *Employee* имеет сразу несколько причин для изме-
нения. Первая связана с основной задачей класса — управ-
лением данными сотрудника. Но есть и вторая: изменения,
связанные с форматированием отчёта для печати, будут
затрагивать класс сотрудников.
До:
![[Pasted image 20221009200038.png]]
Проблему можно решить, выделив операцию печати в
отдельный класс.
После: лишнее поведение переехало в собственный класс:
![[Pasted image 20221009200203.png]]

**O**
##### Принцип открытости/закрытости (open-closed principle)
* «Программные сущности … должны быть открыты для расширения, но закрыты для модификации».
* Расширяйте классы, но не изменяйте их первоначаль-
ный код.

**L**	
##### Принцип подстановки Лисков (Liskov substitution principle)
* «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом».
* Подклассы должны дополнять, а не замещать поведе-
ние базового класса.

* **Типы параметров метода подкласса должны совпадать или
быть более абстрактными, чем типы параметров базового
метода.**
	Базовый класс содержит метод feed(Cat c) , который
умеет кормить домашних котов. Клиентский код это знает
и всегда передаёт в метод кота.
		**Хорошо**: Вы создали подкласс и переопределили метод кормёжки так, чтобы накормить любое животное: feed(Animal c) . Если подставить этот подкласс в клиентский код, то ничего страшного не произойдёт. Клиентский код подаст в метод кота, но метод умеет кормить всех животных, поэтому накормит и кота.
		**Плохо**: Вы создали другой подкласс, в котором метод умеет кормить только бенгальскую породу котов (подкласс котов): feed(BengalCat c) . Что будет с клиентским кодом? Он всё так же подаст в метод обычного кота. Но метод умеет кормить только бенгалов, поэтому не сможет отработать, сломав клиентский код.
* **Тип возвращаемого значения метода подкласса должен сов-
падать или быть подтипом возвращаемого значения базо-
вого метода.** Здесь всё то же, что и в предыдущем пункте, но
наоборот.
	Базовый метод: buyCat(): Cat . Клиентский код ожидает
на выходе любого домашнего кота.
Принципы SOLID / L: Принцип подстановки Лисков
		**Хорошо**: Метод подкласса: buyCat(): BengalCat. 
		Клиентский код получит бенгальского кота, который является домашним котом, поэтому всё будет хорошо.
		**Плохо**: Метод подкласса: buyCat(): Animal . Клиентский код сломается, так как это непонятное животное (возможно, крокодил) не поместится в ящике-переноске для кота.		
		Ещё один анти-пример из мира языков с динамической типизацией: базовый метод возвращает строку, а переопределённый метод — число.
		
* **Метод не должен выбрасывать исключения, которые не
свойственны базовому методу.** Типы исключений в пере-
определённом методе должны совпадать или быть подти-
пами исключений, которые выбрасывает базовый метод.
Блоки try-catch в клиентском коде нацелены на конкрет-
ные типы исключений, выбрасываемые базовым методом.
Поэтому неожиданное исключение, выброшенное подклас-
сом, может проскочить сквозь обработчики клиентского
кода и обрушить программу.
В большинстве современных языков программирова-
ния, особенно строго типизированных (Java, C# и дру-
гие), перечисленные ограничения встроены прямо в
компилятор. 

• **Метод не должен ужесточать пред-условия**. Например,
базовый метод работает с параметром типа int . Если подкласс требует, чтобы значение этого параметра к тому же было больше нуля, то это ужесточает предусловия. Клиентский код, который до этого отлично работал, подавая в
метод негативные числа, теперь сломается при работе с объектом подкласса.
• **Метод не должен ослаблять пост-условия**. Например, базовый метод требует, чтобы по завершению метода все подключения к базе данных были закрыты, а подкласс оставляет эти подключения открытыми, чтобы потом повторно использовать. Но клиентский код базового класса ничего об этом не знает. Он может завершить программу сразу после вызова метода, оставив запущенные процессы-призраки в системе.
• **Инварианты класса должны остаться без изменений**. **Инвариант** — это набор условий, при которых объект имеет смысл. Например, инвариант кота — это наличие четырёх
лап, хвоста, способность мурчать и прочее. Инвариант
может быть описан не только явным контрактом или проверками в методах класса, но и косвенно, например, юнит-тестами или клиентским кодом.
Этот пункт проще всего нарушить при наследовании, так как
вы можете попросту не подозревать о каком-то из условий
инварианта сложного класса. Идеальным в этом отношении
был бы подкласс, который только вводит новые методы и
поля, не прикасаясь к полям базового класса.
• **Подкласс не должен изменять значения приватных полей
базового класса.** Этот пункт звучит странно, но в некоторых
языках доступ к приватным полям можно получить через
механизм рефлексии. В некоторых других языках (Python,
JavaScript) и вовсе нет жёсткой защиты приватных по

**I**	
##### Принцип разделения интерфейса (interface segregation principle)
* «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».
* Клиенты не должны зависеть от методов, которые они
не используют.

**D**
##### Принцип инверсии зависимостей (dependency inversion principle)
* «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».
* Классы верхних уровней не должны зависеть от клас-
сов нижних уровней. Оба должны зависеть от абстрак-
ций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.